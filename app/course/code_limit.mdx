import YoutubeShort from "../components/YoutubeShort";

# How to Never Ever Have a Code Limit

Have you ever noticed that some people can look at a problem and instantly know which algorithm to use? It almost feels like magic—but it’s not! Today, we’ll talk about how **you** can do it too.

The secret? **Pay attention to constraints.**

Algorithms aren’t like superheroes or villains—they’re just tools. Whether they save the day or cause disaster depends entirely on the size of the input. Once you understand this, you’ll never waste time on an inefficient solution again.

## One Number to Remember: `10⁹`

There’s just one number you need to keep in mind: **10⁹**.

This is roughly the number of operations your **computer can handle per second**. That’s why processor speeds are measured in **Gigahertz**—the prefix "Giga" literally means `10⁹`.

Of course, real-world performance depends on a constant factor (`C × 10⁹`), but for quick estimations, `10⁹` is good enough.

## Estimating Running Time Using Constraints

Let’s apply this idea to some coding problems.

### Example 1: [Two Sum](https://leetcode.com/problems/two-sum/description/)

#### Problem Statement
Given an array `nums` and an integer `target`, return the **indices** of two numbers that add up to `target`.

#### Constraints:
- `2 ≤ nums.length ≤ 10⁴`
- `-10⁹ ≤ nums[i] ≤ 10⁹`
- `-10⁹ ≤ target ≤ 10⁹`

Before even thinking about an algorithm, check the constraints. The input size is at most `10⁴`, and most coding platforms allow **1 second** to run the solution.

A **quadratic solution** (`O(n²)`) would require ~`(10⁴)² = 10⁸` operations, which is less than `10⁹`, meaning it should pass just fine.

That’s exactly why this problem is **easy**—even a simple brute-force approach is fast enough!

---

### Example 2: [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)

#### Problem Statement
Given a string `s`, find the length of the longest *substring* without duplicate characters.

#### Constraints:
- `0 ≤ s.length ≤ 5 × 10⁴`

If we try a **quadratic algorithm**, we’d have to do `(5 × 10⁴)² = 25 × 10⁸ = 2.5 × 10⁹` operations. Since our computer can handle `10⁹` operations per second, this would take **2.5 seconds**—too slow!

That means a **quadratic approach is too slow** for this problem. We need something better, like an `O(n log n)` or `O(n)` solution:


Since `2.3 × 10⁵` is **way** less than `10⁹`, an optimized algorithm will run in time. This is why the problem is **medium**—brute force won’t cut it.

---

## How to Use This in a Coding Interview

### Coding Assessments
This technique is super useful for **automated coding assessments**, where you need to impress the system, not a human. If your code times out, knowing how to estimate complexity will help you quickly adjust your approach.

### Live Interviews: Always Ask About Constraints
In real interviews, always ask:
- **How large is the input?**
- **How often will this function be called?**

This helps you understand what matters most—should you optimize for time, space, or simplicity? With this mindset, you’ll make smarter design choices and impress interviewers.

To help you remember, here’s a fun video for you:

<YoutubeShort code="F0lzIjzoOmc"/>
---

## TL;DR
1. **Remember `10⁹`**—the number of operations per second your computer can handle.
2. **Check constraints first**—they tell you what kind of algorithm will work.
3. **Estimate running time**—use quick calculations to see if your approach will be too slow.
4. **Use this in interviews**—ask about constraints to pick the best solution!

Master this, and you’ll **never** have to worry about time limits again!
