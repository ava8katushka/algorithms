import Code from "../components/Code";

> This chapter would be published on 22nd of June 2025.

# Design mindset

Often there is more than 1 solution to any problem.

Let's take a look into a famous [2-sum problem](https://en.wikipedia.org/wiki/Subset_sum_problem).

> Having an array of integers, return any `2` elements that **sum** to a given number called `target`.


## Brute force

### Description
- Consider all the pairs
- If any of them sum to the target, return the result

### Code
<Code>
{
`def two_sum(arr, target):
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] + arr[j] == target:
                return (arr[i], arr[j])
    return None
`
}
</Code>

### Time and Space Complexity

This approach is taking us
- `O(nÂ²)` time
- `O(1)` space

### Why it's working

We have considered all possibilities. If solution is there, we had considered it.

### Benefits

It is simple to understand, it doesn't require additional space.

### Downside

Running time is pretty slow.

## Sorting and sliding window

### Description

- Sort the array
- Consider the pair of elements on the **left** and **right**
- If pair sum is equal to target, return result
- If the pair **sum is smaller, increase it** by considering next element on the left
- If the pair **sum is bigger, decrease it** by considering next element on the right

### Code 

<Code>
{
`def two_sum(arr, target):
    arr.sort()
    start = 0
    end = len(arr) - 1
    while start < end:
        s = arr[start] + arr[end]
        if s == target:
            return (arr[start], arr[end])
        elif s < target:
            start += 1
        else:
            end -= 1
    return None
`
}
</Code>

### Time and Space Complexity

This approach is taking us
- `O(n log n)` time
- `O(n)` space - depending on the sort

### Why it's working

Though it's intuitive, it might not easy to see why some pairs could not be missed.
Let's assume that we miss a pair of indecies `(i, j)` in which `a[i] + a[j] == target`

### Benefits

O(n log n) is not much more than O(n). If array is already sorted, we can take advantage of it.
We use relatively small space - just for sorting. In some sorting algoritms, like heap sort, we would use no auxilary space at all.

### Downside

We might need to copy array in order to sort it, if the user doesn't expect the array to be changed.

## Hashtable

- Save seen elements in the **set**
- For a new element considered, see if it's **complementary** is already in the set
- If it is, we have found the pair ðŸŽ‰
- If not, we will **put current element in the set**

<Code>
{
`def two_sum(arr, target):
    seen = set()
    for a in arr:
        need = target - a
        if need in seen:
            return (need, a)
        seen.add(a)
    return None
`
}
</Code>
This approach is taking us
- `O(n)` time
- `O(n)` space for set

